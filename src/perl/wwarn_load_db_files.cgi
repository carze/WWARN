#!/usr/bin/perl

=head1 NAME

wwarn_load_db_files.cgi - Loads database files created using the wwarn_convert_to_mysql.cgi script into the WWARN database

=head1 SYNOPSIS

./wwarn_load_db_files.cgi
    --input_file=/path/to/individual/db/file
    --input_dir=/path/to/directory/containing/db/files
     
=head1 PARAMETERS

B<--input_file, -i>
    An individual database input file. This should contain data to be loaded into the 
    study, subject, sample, marker or genotype tables.
    
B<--input_dir, -id>
    A directory containing multiple input files. Theses files should be data to be loaded 
    into the WWARN database tables.
        
=head1 DESCRIPTION

This CGI script takes the contents of the wwarn_convert_to_mysql.cgi script and loads all files into the WWARN database.

=head1 INPUT

Usually input here will be a set of 5 tab-delimited text files containing data that correspond to the individual WWARN
database tables:

    1.) study
    2.) subject
    3.) sample
    4.) genotype
    5.) marker

but support is in place to load just one of these files as well.

=head1 OUTPUT

Output will be a JSON object containing success or failure and any error messages that should notify the user in case of a failure in 
the loading process

=head1 CONTACT

    Cesar Arze
    carze@som.umaryland.edu
    
=cut

use strict;
use warnings;
use FileHandle;
use File::Basename;
use Pod::Usage;     
use DBI;
use CGI qw(:standard);
use JSON;
use URI::Escape;
use Config::IniFiles;   
use Log::Log4perl qw(:easy);        

#----------------------------------------------------------
# GLOBALS/COMMAND-LINE OPTIONS
#----------------------------------------------------------
my $logger;
my $cfg;
my $dbh;
my $json = new JSON;
my $results = {};
my $query = new CGI;

my $err_category = { 'c'  => "CRITICAL",
	                 'd'  => "DEBUG",
	                 'w'  => "WARNING"
};

my $db_tables = {  'study'     =>  1,
                   'location'  =>  2,
                   'subject'   =>  3,
                   'sample'    =>  4,
                   'marker'    =>  5,                                                         	
	               'genotype'  =>  6
};

print header("text/html");

## Configure log4perl
Log::Log4perl->easy_init( { level => "ALL", file => "/tmp/wwarn_load.log" } );
$logger = get_logger();                    
                      
## Setup our config object to get DB parameters                     
my $cfg_file = "wwarn-devel.ini";
tie %$cfg, 'Config::IniFiles', ( -file => $cfg_file );                      
my $db_server = $cfg->{'DB'}->{'server'} if ( exists($cfg->{'DB'}->{'server'}) ) || _log_errors("Server missing from DB config file.");
my $db_name = $cfg->{'DB'}->{'name'} if ( exists($cfg->{'DB'}->{'name'}) ) || _log_errors("DB name missing from DB config file.");
my $username = $cfg->{'DB'}->{'username'} if ( exists($cfg->{'DB'}->{'username'}) ) || _log_errors("Username missing from DB config file.");
my $password = $cfg->{'DB'}->{'password'} if ( exists($cfg->{'DB'}->{'password'}) ) || _log_errors("Password missing from DB config file.");
$dbh = DBI->connect("DBI:mysql:database=$db_name;host=$db_server", "$username", "$password", 
                    { RaiseError => 1, PrintError => 1 }) || _log_errors("Could not connect to database $DBI::errstr", "c");
                                                                    
## Parse CGI params
my $input_file = param('input_file');
my $input_dir = param('input_dir');

## Ultimately we want to have an array of files that we can iterate over and load 
## into the database so we have to scan our directory and the input file to gather
## together all our input files
my $db_files = parse_input_files($input_file, $input_dir);

## Now iterate over all our files and load them into the database
load_files_into_db($db_files, $dbh);

## Return our JSON object to the user containing any non-fatal log messages and load success
$results->{'success'} = JSON::true;
$results->{'results'} = [];
print $json->encode(\%$results);

###############################################################################
#####                          SUBROUTINES                                #####
###############################################################################

sub load_files_into_db {
	my ($files, $db_handle) = @_;
	my $sth;
	
	eval {	
		foreach my $file (@$files) {
			## All the files generated by wwarn_convert_to_mysql.cgi should 
			## follow the naming schema of <FILE PREFIX>.<TABLE NAME>.txt 
			## which allows us to extract the table name from the file name.
			my $filename = basename($file, '.txt');
			my $table_name = ( split(/\./, $filename) )[1];
            my $stmt = "LOAD DATA LOCAL INFILE ? INTO TABLE";
			
			if (exists( $db_tables->{$table_name} )) {
				$stmt .= " $table_name";
		        $sth = $db_handle->prepare($stmt);			
			    $sth->execute($file);
			} else {
				_log_error("File $filename does not have a corresponding table in the database", "w");
			}
		}
	};
	if ($@) {
        _log_error("Error loading files into database: $@", "c");		
	}
}

#----------------------------------------------------------
# parse input file and input directory to gather together
# all files that will be loaded into the db
#----------------------------------------------------------
sub parse_input_files {
	my ($in_file, $in_dir) = @_;
    my $files_to_load = ();

    ## First handle our input file if it is defined
    push(@$files_to_load, _qc_input_file($in_file)) if ( defined($in_file) );
	
	## Now slurp in directory and parse our files
	if ( defined($in_dir) ) {
		opendir(DIR, $in_dir) or _log_error("Could not open directory $in_dir", "c");
		my @files = grep { /\.txt$/ && -f "$in_dir/$_"} readdir(DIR);
		foreach my $file (@files) {
			next if (( split(/\./, $file) )[1]  eq "txt");
			my $abs_file = $in_dir . "/" . $file;
			push (@$files_to_load, _qc_input_file($abs_file));
		}
	}
	
	## Want to sort our files so they load in the following order:
	##
	##     1.) study
	##     2.) location
	##     3.) subject
	##     4.) sample
	##     5.) marker
	##     6.) genotype
    my $sorted_files = _sort_input_files($files_to_load);
	return $sorted_files;
}                                                

#----------------------------------------------------------
# Executes some basic QC on input files passed in to 
# avoid any common errors that could occur.
#----------------------------------------------------------
sub _qc_input_file {
	my $file = shift;
	
	## Need to ensure our file exists and is readable
	unless (-e $file)  {  _log_error("File $file does not exist", "c")  }
	unless (-r $file)  {  _log_error("File $file is not readable", "c") }
    unless (-s $file)  {  _log_error("File $file is zero-size", "c")    }
    
    ## TODO: Add more checks here
    return $file;
}

#----------------------------------------------------------
# Logs any errors to our log4perl logger and also will 
# store errors to an array that will be returned to the 
# frontend in a JSON object. 
#----------------------------------------------------------
sub _log_error {
	my ($log_msg, $error_type) = @_;
	
	## Errors can be of type (c)ritical, (w)arning, (d)ebug.
	## If an error is of type critical the program exits 
	## immediately after returning a JSON object.
	if ($error_type eq "c") {
	   $results->{'success'} = JSON::false
	   $results->{'results'} = [];
	   push(@{ $results->{'log'} }, { 'type' => $err_category->{$error_type}, 'msg' => $log_msg });
	   print $json->encode(\%$results);
	   $logger->logdie($log_msg);
	} else {
       push(@{ $results->{'log'} }, { 'type' => $err_category->{$error_type}, 'msg' => $log_msg });
       $logger->warn($log_msg);   	   
	}
}

sub _sort_input_files {
    my $files_to_sort = shift;
    my $sorted = ();
    my $regex = qr/(study|subject|sample|location|marker|genotype)/;
    
    @$sorted = sort { $db_tables->{ ( $a =~ $regex )[0] } <=> $db_tables->{ ( $b =~ $regex )[0] } || $a cmp $b } @$files_to_sort;    
    return $sorted;        
}